import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import React, { createContext, useState, useRef, useEffect, useCallback, useContext } from 'react';
import MetaMaskOnboarding from '@metamask/onboarding';
import { ethers } from 'ethers';

var networkMapper = {
  1: 'mainnet',
  3: 'ropsten',
  4: 'rinkeby',
  5: 'goerli'
};
var NETWORKS = {
  mainnet: {
    hex: '0x1',
    decimal: 1,
    name: 'Ethereum Main Network (Mainnet)'
  },
  ropsten: {
    hex: '0x3',
    decimal: 3,
    name: 'Ropsten Test Network'
  },
  rinkeby: {
    hex: '0x4',
    decimal: 4,
    name: 'Rinkeby Test Network'
  },
  goerli: {
    hex: '0x5',
    decimal: 5,
    name: 'Goerli Test Network'
  }
};

var ConnectionEnum;

(function (ConnectionEnum) {
  ConnectionEnum[ConnectionEnum["NotConnected"] = 0] = "NotConnected";
  ConnectionEnum[ConnectionEnum["Connected"] = 1] = "Connected";
})(ConnectionEnum || (ConnectionEnum = {}));

var Context = /*#__PURE__*/createContext({
  connection: ConnectionEnum.NotConnected,
  account: ''
});
var MetamaskProvider = function MetamaskProvider(_ref) {
  var children = _ref.children;

  var _useState = useState(ConnectionEnum.NotConnected),
      _useState2 = _slicedToArray(_useState, 2),
      connection = _useState2[0],
      setConnection = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isDisabled = _useState4[0],
      setDisabled = _useState4[1];

  var _useState5 = useState([]),
      _useState6 = _slicedToArray(_useState5, 2),
      accounts = _useState6[0],
      setAccounts = _useState6[1];

  var _useState7 = useState(''),
      _useState8 = _slicedToArray(_useState7, 2),
      balance = _useState8[0],
      setBalance = _useState8[1];

  var _useState9 = useState(),
      _useState10 = _slicedToArray(_useState9, 2),
      networkName = _useState10[0],
      setNetworkName = _useState10[1];

  var onboarding = useRef();
  useEffect(function () {
    if (!onboarding.current) {
      onboarding.current = new MetaMaskOnboarding();
    }
  }, []);
  useEffect(function () {
    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      if (accounts.length > 0) {
        var _onboarding$current;

        setConnection(ConnectionEnum.Connected);
        setDisabled(true);
        (_onboarding$current = onboarding.current) === null || _onboarding$current === void 0 ? void 0 : _onboarding$current.stopOnboarding();
      } else {
        setConnection(ConnectionEnum.NotConnected);
        setDisabled(false);
      }
    }
  }, [accounts]);
  useEffect(function () {
    if (MetaMaskOnboarding.isMetaMaskInstalled() && !!accounts.length) {
      window.ethereum.request({
        method: 'eth_getBalance',
        params: [accounts[0], 'latest']
      }).then(function (balance) {
        setBalance(balance);
      });
    }
  }, [accounts]);
  useEffect(function () {
    function handleNewAccounts(newAccounts) {
      setAccounts(newAccounts);
    }

    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      if (window.innerWidth <= 768) {
        window.ethereum.request({
          method: 'eth_requestAccounts'
        }).then(handleNewAccounts);
      }

      window.ethereum.on('accountsChanged', handleNewAccounts);
      return function () {
        window.ethereum.removeListener('accountsChanged', handleNewAccounts);
      };
    }
  }, []);
  useEffect(function () {
    function handleChain() {
      window.location.reload();
    }

    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      window.ethereum.on('chainChanged', handleChain);
      return function () {
        window.ethereum.removeListener('chainChanged', handleChain);
      };
    }
  }, []);
  var connectCb = useCallback(function () {
    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      window.ethereum.request({
        method: 'eth_requestAccounts'
      }).then(function (newAccounts) {
        return setAccounts(newAccounts);
      });
    } else {
      var _onboarding$current2;

      (_onboarding$current2 = onboarding.current) === null || _onboarding$current2 === void 0 ? void 0 : _onboarding$current2.startOnboarding();
    }
  }, []);
  var connectAndGetSignature = useCallback(function (personalSignText, callback) {
    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      window.ethereum.request({
        method: 'eth_requestAccounts'
      }).then(function (newAccounts) {
        var msg = "0x".concat(Buffer.from(personalSignText, 'utf8').toString('hex'));
        window.ethereum.request({
          method: 'personal_sign',
          params: [newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts[0], msg]
        }).then(function (res) {
          setAccounts(newAccounts);
          callback === null || callback === void 0 ? void 0 : callback({
            signature: res,
            account: newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts[0]
          });
        }).catch(function (err) {
          callback === null || callback === void 0 ? void 0 : callback(null, err);
        });
      });
    } else {
      var _onboarding$current3;

      (_onboarding$current3 = onboarding.current) === null || _onboarding$current3 === void 0 ? void 0 : _onboarding$current3.startOnboarding();
    }
  }, []);
  useEffect(function () {
    if (MetaMaskOnboarding.isMetaMaskInstalled()) {
      var provider = new ethers.providers.Web3Provider(window.ethereum);
      var signer = provider.getSigner();
      signer.getChainId().then(function (chainId) {
        setNetworkName(networkMapper[chainId]);
      }).catch(function (e) {
        console.log(e === null || e === void 0 ? void 0 : e.message);
      });
    }
  }, []);
  useEffect(function () {
    if (MetaMaskOnboarding.isMetaMaskInstalled()) ;
  }, [accounts]); // function getContract(contractAddress: string, abi: Array<any>) {
  //   if (
  //     !contractRef.current &&
  //     MetaMaskOnboarding.isMetaMaskInstalled() &&
  //     !!providerRef.current
  //   ) {
  //     const signer = providerRef.current?.getSigner();
  //     contractRef.current = new ethers.Contract(contractAddress, abi, signer);
  //   }
  //   return contractRef.current;
  // }

  return /*#__PURE__*/React.createElement(Context.Provider, {
    value: {
      connect: connectCb,
      disabled: isDisabled,
      connection: connection,
      account: (accounts === null || accounts === void 0 ? void 0 : accounts[0]) || '',
      balance: balance,
      networkName: networkName,
      connectAndGetSignature: connectAndGetSignature
    }
  }, children);
};
var useMetamask = function useMetamask() {
  return useContext(Context);
};

var initialContract = null;
function getContract(contractAddress, contractABI) {
  if (!initialContract && MetaMaskOnboarding.isMetaMaskInstalled()) {
    var provider = new ethers.providers.Web3Provider(window.ethereum);
    var signer = provider.getSigner();
    initialContract = new ethers.Contract(contractAddress, contractABI, signer);
  }

  return initialContract;
}

export { ConnectionEnum, MetamaskProvider, NETWORKS, getContract, networkMapper, useMetamask };
